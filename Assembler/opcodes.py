# 20 bits, 3=[19,17] para jumps, 11=[16,6] señales entrega 1, 6=[5,0] señales entrega 2
# 6 bits entrega 2. [5,4] para selAddres. incPC, decPC, selPC, selDin
opcodes_alt = {
    "NOP": "00000000000000000000",  # en regex \s equivalente a caracter espacio

    # -- MOV --
    "MOVA,B":           "100 00 10 000 0 000 000000",
    "MOVB,A":           "010 10 00 000 0 000 000000",
    # \s equivalente a un espacio
    "MOVA,[a-z0-9]+":   "100 00 11 000 0 000 000000",
    "MOVB,[a-z0-9]+":   "010 00 11 000 0 000 000000",
    "MOVA,\(.+\)":      "100 00 01 000 0 000 000000",
    "MOVB,\(.+\)":      "010 00 01 000 0 000 000000",
    "MOV\(.+\),A":      "001 10 00 000 0 000 000000",
    "MOV\(.+\),B":      "001 00 10 000 0 000 000000",
    # nuevas
    "MOVA,\(B\)":         "100 00 01 000 0000  10 000 0",
    "MOVB,\(B\)":         "010 00 01 000 0000  10 000 0",
    "MOV\(B\),A":         "001 10 00 000 0000  10 000 0",
    "MOV\(B\),[a-z0-9]+": "001 00 11 000 0000  10 000 0",

    # -- ADD -- op = (ADD; SUB, AND, OR, XOR)
    "ADDA,B":           "100 10 10 000 0 000 000000",
    "ADDB,A":           "010 10 10 000 0 000 000000",
    "ADDA,[a-z0-9]+":   "100 10 11 000 0 000 000000",
    "ADDB,[a-z0-9]+":   "010 10 11 000 0 000 000000",
    "ADDA,\(.+\)":      "100 10 01 000 0 000 000000",
    "ADDB,\(.+\)":      "010 10 01 000 0 000 000000",
    "ADD\(.+\)":        "001 10 10 000 0 000 000000",
    # nuevas
    "ADDA,\(B\)":         "100 10 01 000 0000  10 000 0",  # A = A op (B)
    "ADDB,\(B\)":         "010 10 01 000 0000  10 000 0",  # B = A op (B)

    # -- SUB --
    # A = A sub B. reemplazar sub por op. = caso general
    "SUBA,B":           "100 10 10 001 0 000 000000",
    "SUBB,A":           "010 10 10 001 0 000 000000",  # B = A sub B
    "SUBA,[a-z0-9]+":   "100 10 11 001 0 000 000000",  # A = A - lit
    "SUBB,[a-z0-9]+":   "010 10 11 001 0 000 000000",  # B = A - lit
    "SUBA,\(.+\)":      "100 10 01 001 0 000 000000",  # A = A - Mem(dir)
    "SUBB,\(.+\)":      "010 10 01 001 0 000 000000",  # B = A sub
    "SUB\(.+\)":        "001 10 10 001 0 000 000000",  # mem(dir) = A sub B
    # nuevas
    # selAdd(0, 1), incSP, decSP, selPC, selDin
    "SUBA,\(B\)":         "100 10 01 001 0000  10 000 0",
    "SUBB,\(B\)":         "010 10 01 001 0000  10 000 0",

    # -- AND:
    "ANDA,B":           "100 10 10 010 0 000 000000",
    "ANDB,A":           "010 10 10 010 0 000 000000",
    "ANDA,[a-z0-9]+":   "100 10 11 010 0 000 000000",
    "ANDB,[a-z0-9]+":   "010 10 11 010 0 000 000000",
    "ANDA,\(.+\)":      "100 10 01 010 0 000 000000",
    "ANDB,\(.+\)":      "010 10 01 010 0 000 000000",
    "AND\(.+\)":        "001 10 10 010 0 000 000000",
    # nuevas
    "ANDA,\(B\)":         "100 10 01 010 0000  10 000 0",
    "ANDB,\(B\)":         "010 10 01 010 0000  10 000 0",

    # -- OR
    "ORA,B":            "100 10 10 011 0 000 000000",
    "ORB,A":            "010 10 10 011 0 000 000000",
    "ORA,[a-z0-9]+":    "100 10 11 011 0 000 000000",
    "ORB,[a-z0-9]+":    "010 10 11 011 0 000 000000",
    "ORA,\(.+\)":       "100 10 01 011 0 000 000000",
    "ORB,\(.+\)":       "010 10 01 011 0 000 000000",
    "OR\(.+\)":         "001 10 10 011 0 000 000000",
    # nuevas
    "ORA,\(B\)":          "100 10 01 011 0000  10 000 0",
    "ORB,\(B\)":          "010 10 01 011 0000  10 000 0",

    # -- XOR
    "XORA,B":           "100 10 10 100 0 000 000000",
    "XORB,A":           "010 10 10 100 0 000 000000",
    "XORA,[a-z0-9]+":   "100 10 11 100 0 000 000000",
    "XORB,[a-z0-9]+":   "010 10 11 100 0 000 000000",
    "XORA,\(.+\)":      "100 10 01 100 0 000 000000",
    "XORB,\(.+\)":      "010 10 01 100 0 000 000000",
    "XOR\(.+\)":        "001 10 10 100 0 000 000000",
    # nuevas
    "XORA,\(B\)":         "100 10 01 100 0000  10 000 0",  # A = A op (B)
    "XORB,\(B\)":         "010 10 01 100 0000  10 000 0",  # B = A op (B)

    # -- NOT. op2 =(NOT, SHL, SHR).
    "NOTA":             "100 10 00 101 0 000 000000",  # A = op2 A
    "NOTB,A":           "010 10 00 101 0 000 000000",  # B = op2 A
    "NOT\(.+\),A":      "001 10 00 101 0 000 000000",  # mem(dir) = op2 A
    # nueva
    "NOT\(B\),A":         "001 10 00 101 0000  10 000 0",  # mem(B) = op2 A

    # -- SHL
    "SHLA":             "100 10 00 111 0 000 000000",
    "SHLB,A":           "010 10 00 111 0 000 000000",
    "SHL\(.+\),A":      "001 10 00 111 0 000 000000",
    # nueva
    "SHL\(B\),A":         "001 10 00 111 0000  10 0000",  # mem(B) = op2 A

    # -- SHR
    "SHRA":             "100 10 00 110 0 000 000000",
    "SHRB,A":           "010 10 00 110 0 000 000000",
    "SHR\(.+\),A":      "001 10 00 110 0 000 000000",
    # nueva
    "SHR\(B\),A":         "001 10 00 110 0000  10 0000",  # mem(B) = op2 A

    # -- INC
    # Inc A como suma de A con B = literal 1
    "INCA":             "100 10 11 000 0000 000000",
    "INCB":             "010 01 10 000 0000 000000",
    "INC\(.+\)":        "001 01 01 000 0000 000000",
    # nueva
    # Incrementa B en 1. Suma A = 1 con (B)
    "INC\(B\)":           "001 01 01 000 0000  10 000 0",

    # -- DEC
    # B como literal = 1. Resta de A con B
    "DECA":             "100 10 11 001 0000 000000",

    # -- CMP
    "CMPA,B":           "000 10 10 001 0000 000000",  # A - B
    "CMPA,[a-z0-9]+":   "000 10 11 001 0000 000000",  # A - lit
    "CMPA,\(.+\)":      "000 10 01 001 0000 000000",  # A - Mem(dir)
    # nueva
    "CMPA,\(B\)":         "000 10 01 001 0000  10 000 0",  # A - Mem(B)

    # -- JUMPs
    "JMP[a-z0-9]+":     "000 00 00 000 1 000 000000",  # incondicional
    "JEQ[a-z0-9]+":     "000 00 00 000 1 001 000000",  # z = 1
    "JNE[a-z0-9]+":     "000 00 00 000 1 010 000000",  # z = 0
    "JGT[a-z0-9]+":     "000 00 00 000 1 011 000000",  # N = 0 y Z = 0
    "JGE[a-z0-9]+":     "000 00 00 000 1 100 000000",  # N = 0
    "JLT[a-z0-9]+":     "000 00 00 000 1 101 000000",  # N = 1
    "JLE[a-z0-9]+":     "000 00 00 000 1 110 000000",  # N = 1 o Z = 1
    "JCR[a-z0-9]+":     "000 00 00 000 1 111 000000",  # C = 1

    # nuevas
    "PUSHA":            "001 10 00 000 0000  01 010 0",  # Mem(SP) = A, SP -= 1
    # Mem(SP) = B, SP -= 1 # Señal selB mal
    "PUSHB":            "001 00 10 000 0000  01 010 0",
    # SP += 1 - A = mem(SP)
    "POPA":     "00000000000000 00 100 0 - 100 00 01 000 0000  01 000 0",
    # SP += 1 - B = mem(SP)
    "POPB":     "00000000000000 00 100 0 - 010 00 01 000 0000  01 000 0",

    # mem(SP) = PC + 1, PC = lit, SP -= 1
    "CALL[a-z0-9]+":    "001 00 00 000 1000  01 010 1 ",
    # SP += 1 _ PC = mem(SP)
    "RET":     "00000000000000  00 100 0 - 000 00 00 000 1000  01 001 0",

    # Instruccion Extra: Setear SP
    "SSP": "000 00 00 000 0000  00 010 0"  # incSP, decSP, selSP, selDin

    # "PUSH", "POP", "CALL",  "RET" instrucciones E2. selAddres(0, 1), incSP, decSP, selSP, selDin
}

# 11 bits de señales E1 + 3 bits para jumps y finalmente 6 bits señales E2

# Señales E1: La, Lb, w, Sa, Sb , alu, pc
# Señales E2: selAdd1, selAdd2, incSP, selPC, selDin

# MUX A: {0 = 00, 1 = 01, RegA = 10}
# MUX B: {0 = 00, adress = 01, RegB = 10, Lit = 11}
